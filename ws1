# BISECTION METHOD
from sympy import symbols, lambdify, diff, cos, sin, exp
import math
import numpy as np
import matplotlib.pyplot as plt
x = symbols('x')
expr = eval(input("Enter expression: "))
a = float(input("Enter left interval: "))
b = float(input("Enter right interval: "))
f = lambdify(x, expr)

x_vals = np.linspace(a, b, 400)
y_vals = f(x_vals)

plt.plot(x_vals, y_vals, label=r"$f(x) = \cos(x) - x e^x$")
plt.axhline(0, color='black', linewidth=1.5)
plt.axvline(0, color='black', linewidth=1.5)
plt.title("Graph of $f(x) = \cos(x) - x e^x$")
plt.legend()
plt.grid(True)
plt.xlabel("x")
plt.ylabel("f(x)")
plt.show()

epsilon = 0.001
while(abs(a-b) > epsilon):
    mid = (a+b)/2
    fa = expr.subs(x,a)
    fb = expr.subs(x,b)
    fc = expr.subs(x,mid)
    if fa*fc < 0:
     	b = mid
    else:
        a = mid
print(f'root={mid}')


#REGULA FALSI METHOD

# import sympy as sp
# import math
# x = sp.symbols('x')
# expr = eval(input("Enter expression: "))
# a = float(input("Enter left interval: "))
# b = float(input("Enter right interval: "))
# sp.plot(expr,(x,a,b))
# epsilon = 0.001
# max_it = 1000
# for i in range(max_it):
#     fa = expr.subs(x,a)
#     fb = expr.subs(x,b)
#     mid = (a*fb - b*fa)/(fb - fa)
#     fc = expr.subs(x,mid)
#     if abs(a-b) < epsilon:
#         break
#     if fa*fc < 0:
#      	b = mid
#     else:
#      	a = mid
# print(f'root={mid}')


# #NEWTON RAPHSON METHOD

# import sympy as sp
# x = sp.symbols('x')
# expr = eval(input("Enter expression: "))
# x1 = float(input("Enter left interval: "))
# x2 = float(input("Enter right interval: "))
# sp.plot(expr,(x,x1,x2))
# dif = sp.diff(expr,x)
# epsilon = 0.001
# max_it = 100
# fx1 = expr.subs(x,x1)
# fx2 = expr.subs(x,x2)
# x0 = (x1+x2)/2

# for i in range(max_it):
#     ft = expr.subs(x,x0)
#     temp = x0 - ft/dif.subs(x,x0)
#     if abs(x0 - temp) < epsilon:
#         break
#     x0 = temp
# print(f'root={temp}')
  

# #FIXED POINT ITERATION METHOD

# import sympy as sp
# x = sp.symbols('x')
# f = eval(input("Enter f(x): "))
# g = eval(input("Enter g(x): "))
# x1 = float(input("Enter left interval: "))
# x2 = float(input("Enter right interval: "))
# sp.plot(f,(x,x1,x2))
# sp.plot(g,(x,x1,x2))
# epsilon = 0.001
# max_it = 1000
# x0 = (x1 + x2)/2
# for i in range(max_it):
#     temp = g.subs(x,x0)
#     if abs(temp - x0) < epsilon:
#         break
#     x0 = temp
# print(f'root={temp}')
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
#Graffe's Root Squaring Method
import matplotlib.pyplot as plt
import numpy as np
import sympy as sp

n = int(input("degree = "))
x = sp.symbols('x')
expr = eval(input("Enter expression: "))
expr= sp.sympify(expr)
arr = []
for i in range(n+1):
    arr.append(expr.coeff(x,i))
print(arr)
f = sp.lambdify(x,expr)

a=arr
j = 1
flag = 0
sol=np.zeros(n)
while(flag == 0 and j<8):
    b=np.zeros(n+1)
    for i in range(n+1):
        x,y = i-1,i+1
        sum = a[i]**2
        t = 1
        while(x>-1 and y<n+1):
            sum =sum + ((-1)**t)*(2*a[x]*a[y])
            x = x-1
            y = y+1
            t = t+1
        b[i]=sum
    for i in range(n):import numpy as np
import sympy as sp


x = sp.Symbol('x')

n = int(input("Size of Matrix : "))
# tol = 0.001
print("Enter Elements : ")
arr=[]
for i in range(n):
    t = []
    for j in range(n):
        temp = int(input())
        t.append(temp)
    arr.append(t)

arr = sp.Matrix(arr)
sp.pprint(arr)
matrix = sp.Matrix(arr) - x * sp.eye(n)

det = matrix.det()


eq = sp.Eq(det, 0)
eigen_values = sp.solve(eq, x)
print(eigen_values)

eigenvects = arr.eigenvects()
# print(eigenvects)
for i in eigenvects:
    sp.pprint(i[n-1])

        sol[i] = (b[i]/b[i+1])**(1/(2**j))
    print(b)
    print(sol)
    flag = 1
    for i in range(n):
        if (f(sol[i])!=0):
            flag = 0
    if flag ==1:
        break
    j=j+1
    a = b

print(sol)

num = np.linspace(-1, 5, 400) 
y = f(num)
plt.plot(num, y)
plt.show()
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
Power Method
import numpy as np

def power_method(A, num_iterations=100, tolerance=1e-6):
    n = A.shape[0]
    b = np.random.rand(n)  # start with a random vector
    
    # Normalize the initial vector
    b = b / np.sqrt(np.sum(b ** 2))

    for _ in range(num_iterations):
        # Perform the matrix-vector multiplication
        b_new = np.dot(A, b)
        
        # Estimate the eigenvalue using the Rayleigh quotient
        eigenvalue = np.dot(b_new, b) / np.dot(b, b)
        
        # Normalize the new vector
        b_new = b_new / np.sqrt(np.sum(b_new ** 2))
        
        # Check for convergence
        if np.sqrt(np.sum((b - b_new) ** 2)) < tolerance:
            break
        
        b = b_new
    
    return eigenvalue, b

def main():
    n = int(input("Enter the order of the matrix: "))
    A = np.zeros((n, n))

    print("Enter the matrix elements:")
    for i in range(n):
        for j in range(n):
            A[i, j] = float(input(f"Enter element [{i}][{j}]: "))

    eigenvalue, eigenvector = power_method(A)
    print("\nLargest eigenvalue:", eigenvalue)
    print("Corresponding eigenvector:", eigenvector)

if __name__ == "__main__":
    main()
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
Gauss Jordan

# Importing NumPy Library
import numpy as np

# Reading number of unknowns
n = int(input('Enter number of unknowns: '))

# Making numpy array of n x n+1 size and initializing 
# to zero for storing augmented matrix
a = np.zeros((n, n+1))

# Making numpy array of n size and initializing 
# to zero for storing solution vector
x = np.zeros(n)

# Reading augmented matrix coefficients
print('Enter Augmented Matrix Coefficients:')
for i in range(n):
    for j in range(n+1):
        a[i][j] = float(input('a[' + str(i) + '][' + str(j) + ']='))

# Applying Gauss-Jordan Elimination
for i in range(n):
    for j in range(n):

        if(i!=j):
            ratio = a[j][i] / a[i][i]

            for k in range(n+1):
                a[j][k] = a[j][k] - ratio * a[i][k]

            # Print the matrix after each row operation
            print(f"\nMatrix after making row {j+1} zero below pivot at row {i+1}:")
            print(a)


# Obtaining Solution
for i in range(n):
    x[i] = a[i][n] / a[i][i]
print("RREF ")
for i in range(n):
    temp = a[i][i]
    for j in range(n+1):
        a[i][j] = a[i][j] / temp
print(a)
# Displaying solution
print('\nRequired solution is: ')
for i in range(n):
    print('X%d = %0.2f' % (i, x[i]), end='\t')
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
